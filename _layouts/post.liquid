---
layout: default
---
{% assign year = page.date | date: '%Y' %}
{% assign tags = page.tags | join: '' %}
{% assign categories = page.categories | join: '' %}
{% assign url_beginning = page.url | slice: 0, 6 %}

{% if page._styles %}
  <!-- Page/Post style -->
  <style type="text/css">
    {{ page._styles }}
  </style>
{% endif %}

<div class="post">
  <header class="post-header">
    <h1 class="post-title">{{ page.title }}</h1>
    <p class="post-meta">
      Created on {{ page.date | date: '%B %d, %Y' }}
      {% if page.author %}by {{ page.author }}{% endif %}
      {% if page.last_updated %}, last updated on {{ page.last_updated | date: '%B %d, %Y' }}{% endif %}
      {% if page.meta %}â€¢ {{ page.meta }}{% endif %}
    </p>
  </header>

  <article class="post-content">
    {% if page.toc and page.toc.beginning %}
      <div id="table-of-contents">
        {% toc %}
      </div>
      <hr>
    {% endif %}
    <div id="markdown-content">
      {{ content }}
    </div>
  </article>

  {% if page.citation %}
    {% include citation.liquid %}
  {% endif %}
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const images = document.querySelectorAll("#markdown-content img");
  let loadQueue = [];
  let currentlyLoading = 0;
  const maxConcurrentLoads = 3; // Load 3 images at a time

  for (const [index, img] of images.entries()) {
    try {
      const url = new URL(img.src);
      if (!url.hostname.includes("images.mostlyrocks.com")) continue;

      const pathParts = url.pathname.split("/");
      const filename = pathParts.pop();
      const folder = pathParts.join("/");
      const v = Date.now();

      const src1200 = `${url.origin}${folder}/thumbs/1200/${filename}?v=${v}`;
      const fallback = `${url.origin}${folder}/${filename}?v=${v}`;

      if (index < 4) {
        // Load first 4 immediately
        img.setAttribute("src", src1200);
        img.setAttribute("fetchpriority", "high");
        
        img.onerror = () => {
          console.warn(`Thumbnail not found, falling back: ${src1200}`);
          img.src = fallback;
        };
      } else {
        // Queue the rest for sequential loading
        img.setAttribute("data-src", src1200);
        img.setAttribute("data-fallback", fallback);
        img.setAttribute("src", "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1 1'%3E%3C/svg%3E");
        loadQueue.push({ img, index, src1200, fallback });
      }
    } catch (e) {
      console.warn("Could not process image:", img, e);
    }
  }

  // Function to load next batch of images
  function loadNextBatch() {
    while (currentlyLoading < maxConcurrentLoads && loadQueue.length > 0) {
      const { img, src1200, fallback } = loadQueue.shift();
      currentlyLoading++;

      // Create a new image to preload
      const loader = new Image();
      
      loader.onload = () => {
        img.src = src1200;
        currentlyLoading--;
        loadNextBatch(); // Load next image
      };
      
      loader.onerror = () => {
        console.warn(`Thumbnail not found, falling back: ${src1200}`);
        img.src = fallback;
        currentlyLoading--;
        loadNextBatch(); // Load next image
      };
      
      loader.src = src1200;
    }
  }

  // Start loading the queue
  loadNextBatch();

  // Also load images when they come into viewport (backup for long pages)
  if ('IntersectionObserver' in window) {
    const imageObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target;
          const dataSrc = img.getAttribute('data-src');
          const dataFallback = img.getAttribute('data-fallback');
          
          if (dataSrc && img.src.includes('data:image/svg+xml')) {
            // Find this image in the queue and prioritize it
            const queueIndex = loadQueue.findIndex(item => item.img === img);
            if (queueIndex !== -1) {
              const item = loadQueue.splice(queueIndex, 1)[0];
              loadQueue.unshift(item); // Move to front of queue
            }
          }
        }
      });
    }, {
      rootMargin: '400px' // Start loading when 400px away
    });

    // Observe all queued images
    loadQueue.forEach(item => imageObserver.observe(item.img));
  }
});
</script>
